/*******************************************************************************
 * Copyright (c) 2010, 2011 SAP AG and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     SAP AG - initial API and implementation
 *******************************************************************************/
package org.eclipse.skalli.gerrit.client.internal;

import java.io.File;
import java.lang.reflect.Method;
import java.text.MessageFormat;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Set;

import org.apache.commons.io.FileUtils;
import org.eclipse.skalli.gerrit.client.GerritClient;
import org.eclipse.skalli.gerrit.client.exception.CommandException;
import org.eclipse.skalli.gerrit.client.exception.ConnectionException;
import org.eclipse.skalli.gerrit.client.exception.GerritClientException;
import org.eclipse.skalli.gerrit.client.internal.GSQL.ResultFormat;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Assert;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@SuppressWarnings("nls")
public class GerritClientTest {

  private static final Logger LOG = LoggerFactory.getLogger(GerritClientTest.class);
  private static final SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss-SSS", Locale.ENGLISH);

  // DO NOT CONFIGURE A PRODUCTIVE GERRIT - the test case created a huge amount of projects and groups that cannot be removed easily.
  private static String TEST_HOST = null;
  private static String TEST_ADMIN_ACCOUNT = null;
  private static int TEST_PORT = 8080;
  private static String TEST_PRIVATEKEY_FILE = null;
  private static String TEST_PASSPHRASE = null;
  private static final String TEST_ONBEHALFOF = "userId";

  // DO NOT MODIFY THIS DESCRIPTION - it is used in the clean up step to figure out which projects and groups have been created.
  private static final String DESCRIPTION = "Generated by jUnit";

  // implementation under test
  private static GerritClientImpl client;

  @BeforeClass
  public static void setUpOnce() throws Exception {
    TEST_HOST = System.getProperty("testHost");
    TEST_ADMIN_ACCOUNT = System.getProperty("testAdminAccount");
    String port = System.getProperty("testPort");
    TEST_PORT = port != null ? new Integer(port).intValue() : TEST_PORT;
    TEST_PRIVATEKEY_FILE = System.getProperty("testPrivatekeyFile");
    TEST_PASSPHRASE = System.getProperty("testPassphrase");
    String privateKey = FileUtils.readFileToString(new File(TEST_PRIVATEKEY_FILE));
    client = new GerritClientImpl(TEST_HOST, TEST_PORT, TEST_ADMIN_ACCOUNT, privateKey, TEST_PASSPHRASE,
        TEST_ONBEHALFOF);
  }

  @Before
  public void setUp() throws Exception {
    client.connect();
  }

  @After
  public void tearDown() throws Exception {
    client.disconnect();
  }

  @AfterClass
  public static void tearDownOnce() throws Exception {
    // clean up and delete all groups + projects that still exist
    String privateKey = FileUtils.readFileToString(new File(TEST_PRIVATEKEY_FILE));
    EvilGerritClient evilClient = new EvilGerritClient(TEST_HOST, TEST_PORT, TEST_ADMIN_ACCOUNT, privateKey,
        TEST_PASSPHRASE, TEST_ONBEHALFOF);
    evilClient.connect();

    /*
     * Deleting groups and clean up. Added WHERE clause that should avoid deleting system groups accidentally
     */
    final StringBuffer deleteGroupsQueries = new StringBuffer();
    deleteGroupsQueries.append("DELETE FROM ").append(GSQL.Tables.ACCOUNT_GROUPS);
    deleteGroupsQueries.append(" WHERE description = '").append(DESCRIPTION).append("'");
    deleteGroupsQueries.append(" AND group_id NOT IN (SELECT admin_group_id FROM ").append(GSQL.Tables.SYSTEM_CONFIG)
        .append(")");
    deleteGroupsQueries.append(" AND group_id NOT IN (SELECT anonymous_group_id FROM ")
        .append(GSQL.Tables.SYSTEM_CONFIG).append(")");
    deleteGroupsQueries.append(" AND group_id NOT IN (SELECT registered_group_id FROM ")
        .append(GSQL.Tables.SYSTEM_CONFIG).append(")");
    deleteGroupsQueries.append(" AND group_id NOT IN (SELECT batch_users_group_id FROM ")
        .append(GSQL.Tables.SYSTEM_CONFIG).append(");");
    // clean up
    deleteGroupsQueries.append("DELETE FROM ").append(GSQL.Tables.ACCOUNT_GROUP_NAMES)
        .append(" WHERE group_id NOT IN (SELECT group_id FROM ").append(GSQL.Tables.ACCOUNT_GROUPS).append(");");
    deleteGroupsQueries.append("DELETE FROM ").append(GSQL.Tables.ACCOUNT_GROUP_MEMBERS)
        .append(" WHERE group_id NOT IN (SELECT group_id FROM ").append(GSQL.Tables.ACCOUNT_GROUPS).append(");");
    deleteGroupsQueries.append("DELETE FROM ").append(GSQL.Tables.ACCOUNT_GROUP_MEMBERS_AUDIT)
        .append(" WHERE group_id NOT IN (SELECT group_id FROM ").append(GSQL.Tables.ACCOUNT_GROUPS).append(");");
    evilClient.gsql(deleteGroupsQueries.toString(), GSQL.ResultFormat.PRETTY);

    /*
     * Deleting projects and clean up according to:
     * http://groups.google.com/group/repo-discuss/browse_thread/thread/9fa2f8978d422709?fwc=1
     *
     * Note: This does not clean up on file system.
     * So creating a project w/ the same name again won't work.
     * Hence the test cases always use project names with a timestamp.
     */
    final StringBuffer deleteProjectsQueries = new StringBuffer();
    deleteProjectsQueries.append("DELETE FROM ").append(GSQL.Tables.PROJECTS).append(" WHERE description = '")
        .append(DESCRIPTION).append("';");
    // clean up
    deleteProjectsQueries.append("DELETE FROM ").append(GSQL.Tables.REF_RIGHTS)
        .append(" WHERE project_name NOT IN (SELECT name FROM ").append(GSQL.Tables.PROJECTS).append(");");
    evilClient.gsql(deleteProjectsQueries.toString(), ResultFormat.PRETTY);

    evilClient.disconnect();
  }

  @Test
  public void testGroupExists() throws Exception {
    final String name = generateName("g");

    Assert.assertFalse(client.groupExists(name));
    client.createGroup(name, null, DESCRIPTION, null);
    Assert.assertTrue(client.groupExists(name));
  }

  @Test
  public void testProjectExists() throws Exception {
    final String name = generateName("p");
    Assert.assertFalse(client.projectExists(name));
    client.createProject(name, null, null, null, false, DESCRIPTION, null, false, false);
    Assert.assertTrue(client.projectExists(name));
  }

  @Test
  public void testCreateGroup() throws Exception {
    final String name = generateName("g");

    Assert.assertFalse(client.groupExists(name));
    client.createGroup(name, null, DESCRIPTION, null);
    Assert.assertTrue(client.groupExists(name));
  }

  @Test(expected = CommandException.class)
  public void testCreateGroupTwice() throws Exception {
    final String name = generateName("g");

    client.createGroup(name, null, DESCRIPTION, null);
    client.createGroup(name, null, DESCRIPTION, null);
  }

  @Test
  public void testCreateProject() throws Exception {
    final String name = generateName("p");

    Assert.assertFalse(client.projectExists(name));
    client.createProject(name, null, null, null, false, DESCRIPTION, null, false, false);
    Assert.assertTrue(client.projectExists(name));
  }

  @Test(expected = CommandException.class)
  public void testCreateProjectTwice() throws Exception {
    final String name = generateName("p");

    client.createProject(name, null, null, null, false, DESCRIPTION, null, false, false);
    client.createProject(name, null, null, null, false, DESCRIPTION, null, false, false);
  }

  @Test
  public void testGetProjects() throws Exception {
    Assert.assertNotNull(client.getProjects());
  }

  @Test
  public void testGetGroups() throws Exception {
    Assert.assertNotNull(client.getGroups());
  }

  @Test
  public void testGetGroupsForProject() throws Exception {
    final String g1 = generateName("g1");
    final String g2 = generateName("g2");
    final String g3 = generateName("g3");

    final String p1 = generateName("p1");
    final String p2 = generateName("p2");

    client.createGroup(g1, null, DESCRIPTION, null);
    client.createGroup(g2, null, DESCRIPTION, null);
    client.createGroup(g3, null, DESCRIPTION, null);

    client.createProject(p1, null, new HashSet<String>(Arrays.asList(g1, g2)), null, false, DESCRIPTION, null, false,
        false);
    client.createProject(p2, null, new HashSet<String>(Arrays.asList(g2, g3)), null, false, DESCRIPTION, null, false,
        false);

    List<String> groupsForP1 = client.getGroups(p1);
    Assert.assertTrue(groupsForP1.contains(g1));
    Assert.assertTrue(groupsForP1.contains(g2));
    Assert.assertFalse(groupsForP1.contains(g3));

    List<String> groupsForP2 = client.getGroups(p2);
    Assert.assertFalse(groupsForP2.contains(g1));
    Assert.assertTrue(groupsForP2.contains(g2));
    Assert.assertTrue(groupsForP2.contains(g3));
  }

  @Test
  public void testGetGroupsForProjects() throws Exception {
    final String g1 = generateName("g1");
    final String g2 = generateName("g2");
    final String g3 = generateName("g3");

    final String p1 = generateName("p1");
    final String p2 = generateName("p2");

    client.createGroup(g1, null, DESCRIPTION, null);
    client.createGroup(g2, null, DESCRIPTION, null);
    client.createGroup(g3, null, DESCRIPTION, null);

    client
        .createProject(p1, null, new HashSet<String>(Arrays.asList(g1)), null, false, DESCRIPTION, null, false, false);
    client
        .createProject(p2, null, new HashSet<String>(Arrays.asList(g2)), null, false, DESCRIPTION, null, false, false);

    List<String> groupsForP1 = client.getGroups(p1, p2);
    Assert.assertTrue(groupsForP1.contains(g1));
    Assert.assertTrue(groupsForP1.contains(g2));
    Assert.assertFalse(groupsForP1.contains(g3));
  }

  @Test
  public void testInvalidProjectNames() throws Exception {
    String[] invalidProjectNames = new String[] { null, "", " ", "/", "/project", "project/", "my project" };
    for (String invalidProjectName : invalidProjectNames) {
      try {
        client.createProject(invalidProjectName, null, null, null, false, DESCRIPTION, null, false, false);
        Assert.fail(String.format("No error for project name '%s'.", invalidProjectName));
      } catch (GerritClientException e) {
        LOG.debug(MessageFormat.format("'{0}' is identified as an invalid project name.", invalidProjectName));
      } catch (IllegalArgumentException e) {
        LOG.debug(MessageFormat.format("'{0}' is identified as an invalid project name.", invalidProjectName));
      }
    }
  }

  @Test
  public void testInvalidGroupNames() throws Exception {
    String[] invalidGroupNames = new String[] { null, "" };
    for (String invalidGroupName : invalidGroupNames) {
      try {
        client.createGroup(invalidGroupName, null, DESCRIPTION, null);
        Assert.fail(String.format("No error for group name '%s'.", invalidGroupName));
      } catch (GerritClientException e) {
        LOG.debug(MessageFormat.format("'{0}' is identified as an invalid group name.", invalidGroupName));
      } catch (IllegalArgumentException e) {
        LOG.debug(MessageFormat.format("'{0}' is identified as an invalid group name.", invalidGroupName));
      }
    }
  }

  @Test
  public void testGetKnownAccounts() throws Exception {
    String unknownAccount = System.currentTimeMillis() + "";
    Set<String> variousAccounts = new HashSet<String>(Arrays.asList(TEST_ADMIN_ACCOUNT, "", null, unknownAccount));
    Set<String> knownAccounts = client.getKnownAccounts(variousAccounts);

    Assert.assertEquals(1, knownAccounts.size());
    Assert.assertTrue(knownAccounts.contains(TEST_ADMIN_ACCOUNT));
    Assert.assertFalse(knownAccounts.contains(unknownAccount));
  }

  @Test
  public void testGetKnownAccountsEmpty() throws Exception {
    Set<String> knownAccounts = client.getKnownAccounts(Collections.<String> emptySet());

    Assert.assertEquals(0, knownAccounts.size());
  }

  @Test
  public void testGetALotOfKnownAccounts() throws Exception {
    Set<String> variousAccounts = new HashSet<String>();
    // don't use an even number. challenge the system :)
    for (int i = 0; i < 123; i++) {
      String unknownAccount = System.currentTimeMillis() + "_" + i;
      variousAccounts.add(unknownAccount);
    }
    variousAccounts.add(TEST_ADMIN_ACCOUNT);

    Set<String> knownAccounts = client.getKnownAccounts(variousAccounts);

    Assert.assertEquals(1, knownAccounts.size());
  }

  // null and empty configurations are already checked by GerritService

  @Test(expected = IllegalArgumentException.class)
  public void testInvalidSettingsIllegalHost() throws Exception {
    String privateKey = FileUtils.readFileToString(new File(TEST_PRIVATEKEY_FILE));
    new GerritClientImpl(null, TEST_PORT, TEST_ADMIN_ACCOUNT, TEST_PRIVATEKEY_FILE, TEST_PASSPHRASE, TEST_ONBEHALFOF);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testInvalidSettingsIllegalPort() throws Exception {
    String privateKey = FileUtils.readFileToString(new File(TEST_PRIVATEKEY_FILE));
    new GerritClientImpl(TEST_HOST, -1, TEST_ADMIN_ACCOUNT, privateKey, TEST_PASSPHRASE, TEST_ONBEHALFOF);
  }

  @Test(expected = ConnectionException.class)
  public void testInvalidSettingsHost() throws Exception {
    String privateKey = FileUtils.readFileToString(new File(TEST_PRIVATEKEY_FILE));
    GerritClient invalidClient = new GerritClientImpl("some.host.corp", TEST_PORT, TEST_ADMIN_ACCOUNT, privateKey,
        TEST_PASSPHRASE, TEST_ONBEHALFOF);
    invalidClient.connect();
  }

  @Test(expected = ConnectionException.class)
  public void testInvalidSettingsPort() throws Exception {
    String privateKey = FileUtils.readFileToString(new File(TEST_PRIVATEKEY_FILE));
    GerritClient invalidClient = new GerritClientImpl(TEST_HOST, 50000, TEST_ADMIN_ACCOUNT, privateKey,
        TEST_PASSPHRASE, TEST_ONBEHALFOF);
    invalidClient.connect();
  }

  @Test(expected = ConnectionException.class)
  public void testInvalidSettingsUser() throws Exception {
    String privateKey = FileUtils.readFileToString(new File(TEST_PRIVATEKEY_FILE));
    GerritClient invalidClient = new GerritClientImpl(TEST_HOST, TEST_PORT, "LoremIpsum", privateKey, TEST_PASSPHRASE,
        TEST_ONBEHALFOF);
    invalidClient.connect();
  }

  @Test(expected = ConnectionException.class)
  public void testInvalidSettingsPrivateKey() throws Exception {
    GerritClient invalidClient = new GerritClientImpl(TEST_HOST, TEST_PORT, TEST_ADMIN_ACCOUNT, "this.one",
        TEST_PASSPHRASE, TEST_ONBEHALFOF);
    invalidClient.connect();
  }

  @Test(expected = ConnectionException.class)
  public void testInvalidSettingsPassphrase() throws Exception {
    String privateKey = FileUtils.readFileToString(new File(TEST_PRIVATEKEY_FILE));
    GerritClient invalidClient = new GerritClientImpl(TEST_HOST, TEST_PORT, TEST_ADMIN_ACCOUNT, privateKey,
        "invalid.passphrase", TEST_ONBEHALFOF);
    invalidClient.connect();
  }

  @Test(expected = IllegalArgumentException.class)
  public void testInvalidSettingsIllegalBehalfOfUserId() throws Exception {
    String privateKey = FileUtils.readFileToString(new File(TEST_PRIVATEKEY_FILE));
    GerritClient invalidClient = new GerritClientImpl(TEST_HOST, TEST_PORT, TEST_ADMIN_ACCOUNT, privateKey,
        "invalid.passphrase", null);
    invalidClient.connect();
  }

  @Test
  public void testUnsupportedGSQLCommands() throws Exception {
    String[] invalidCommands = new String[] { "show", "insert", "update", "delete", "merge", "create", "alter",
        "rename", "truncate", "drop" };
    for (String invalidCommand : invalidCommands) {
      try {
        client.gsql("SELECT * FROM unknown_table_xyz;" + invalidCommand + " bla bla", GSQL.ResultFormat.JSON);
      } catch (UnsupportedOperationException e) {
        continue;
      }
      Assert.fail("Command '" + invalidCommand + "' should not work on gsql(), but was not detected.");
    }
  }

  /**
   * Due to the fact that project names can only be used once (won't be deleted from Git) we
   * generate new names for each run.
   *
   * @param prefix a fixed prefix
   * @return a random name (using the date & time) starting with the fixed prefix
   */
  private static String generateName(String name) {
    return "junit/" + df.format(new Date()) + "/" + name;
  }

  /**
   * YOU MUST NOT USE THIS ON PRODUCTIVE GERRIT INSTANCES!
   * (utility to clean up a test Gerrit instance)
   */
  private static class EvilGerritClient extends GerritClientImpl {

    private EvilGerritClient(String host, int port, String user, String privateKeyFile, String password,
        String onBehalfOfUserId) {
      super(host, port, user, privateKeyFile, password, onBehalfOfUserId);
    }

    @Override
    @SuppressWarnings("unchecked")
    List<String> gsql(String query, ResultFormat format) throws ConnectionException, CommandException {
      final StringBuffer sb = new StringBuffer("gerrit gsql");

      sb.append(" --format ").append(format.name());
      sb.append(" -c \"").append(query).append("\"");

      // Here comes the evil part: Overriding gsql(), allowing modifying commands and using reflection to call a private method...
      try {
        Method sshCommand = this.getClass().getSuperclass().getDeclaredMethod("sshCommand", String.class);
        sshCommand.setAccessible(true);
        return (List<String>) sshCommand.invoke(this, sb.toString());
      } catch (Exception e) {
        throw new RuntimeException(e);
      }
    }
  }

}
